<div align="center">
   <img width="512" height="212" alt="corazon (1)" src="https://github.com/user-attachments/assets/e3c2a14a-4193-4b9e-beb7-cd1ef1b7a47e" />

 
  <h1>ğŸ…³ğŸ†„ğŸ…°ğŸ…» ğŸ†€ğŸ†„ğŸ…°ğŸ…½ğŸ†ƒğŸ†„ğŸ…¼ ğŸ…²ğŸ…¸ğŸ†ğŸ…²ğŸ†„ğŸ…¸ğŸ†ƒ ğŸ†‚ğŸ…¸ğŸ…¼ğŸ†„ğŸ…»ğŸ…°ğŸ†ƒğŸ…¾ğŸ†</h1>
  <p>ğ™° ğšœğš’ğš–ğšğš•ğšŠğšğš’ğš˜ğš— ğš˜ğš ğš€ğšğšŠğš—ğšğšğš– ğš’ğš—ğšğš˜ğš›ğš–ğšŠğšğš’ğš˜ğš— ğšğš›ğšŠğšŸğšğš›ğšœğš’ğš—ğš ğšŠ ğš ğš˜ğš›ğš–ğš‘ğš˜ğš•ğš, ğš‹ğšŠğšœğšğš ğš˜ğš— ğšğš‘ğšğš˜ğš›ğšğšğš’ğšŒğšŠğš• ğš™ğš‘ğš¢ğšœğš’ğšŒğšœ ğš™ğš›ğš’ğš—ğšŒğš’ğš™ğš•ğšğšœ.</p>
   <a href="https://github.com/tlacaelel666/">
        <img src="https://img.shields.io/badge/SmokApp-Software-black?logo=data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNNDcuNiAzMDBjOS42IDI2LjQgMjYuNSA0OS4zIDQ4LjQgNjYuNGw0MCAzMS43Yy00LTEwLjgtNi4zLTIyLjUtNi4zLTM0LjZjMC0yMy4zIDguOS00NC42IDIzLjQtNjAuNmwtNTEuNi00MC4xQzc0IDI4Ny42IDU3LjMgMzA2LjUgNDcuNiAzMDB6bTI0OS41LTE2LjZjMTQuNSAxNiAyMy40IDM3LjMgMjMuNCA2MC42YzAgMTIuMS0yLjMgMjMuOC02LjMgMzQuNmw0MC0zMS43YzIxLjktMTcuMSAzOC44LTM5LjkgNDguNC02Ni40Yy05LjgtNi41LTI2LjUtMjUuNC00NC05NGwtNTEuNiA0MC4xem0tMzUuMiAzOS4yYzAgMjYuNS0yMS41IDQ4LTQ4IDQ4cy00OC0yMS41LTQ4LTQ4czIxLjUtNDggNDgtNDhzNDggMjEuNSA0OCA0OHptLTQ4LTE5MmMtODguNCAwLTE2MCA3MS42LTE2MCAxNjBjMCAzMy43IDEwLjQgNjQuOCAyOC4xIDkwLjZsNTguNy00NS41Yy0xMC01LjQtMTYuOC0xNi4xLTE2LjgtMjguNWMwLTE3LjcgMTQuMy0zMiAzMi0zMnMzMiAxNC4zIDMyIDMyYzAgMTIuNC02LjggMjMuMS0xNi44IDI4LjVsNTguNyA0NS41YzE3LjctMjUuOCAyOC4xLTU2LjkgMjguMS05MC42YzAtODguNC03MS42LTE2MC0xNjAtMTYwem0yNC03MHYzMi45YzE0LjkgNC4wNCAyOS40IDEwLjA0IDQyLjkgMTguMWwyMy4xLTIzLjFsMjIuNiAyMi42bC0yMy4xIDIzLjFjOC4wNyAxMy41IDE0LjEgMjguMSAxOC4xIDQyLjlIMzYwdjMyaC0zMi45Yy00LjA0IDE0LjktMTAuMDQgMjkuNC0xOC4xIDQyLjlsMjMuMSAyMy4xbC0yMi42IDIyLjZsLTIzLjEtMjMuMWMtMTMuNSA4LjA3LTI4LjEgMTQuMS00Mi45IDE4LjFWMzUyaC0zMnYtMzIuOWMtMTQuOS00LjA0LTI5LjQtMTAuMDQtNDIuOS0xOC4xbC0yMy4xIDIzLjFsLTIyLjYtMjIuNmwyMy4xLTIzLjFjLTguMDctMTMuNS0xNC4xLTI4LjEtMTguMS00Mi45SDE1MnYtMzJoMzIuOWM0LjA0LTE0LjkgMTAuMDQtMjkuNCA4LjEtNDIuOWwtMjMuMS0yMy4xbDIyLjYtMjIuNmwyMy4xIDIzLjFjMTMuNS04LjA3IDI4LjEtMTQuMSA0Mi45LTE4LjFWMzJoMzJ6Ii8+PC9zdmc+" alt="SmokApp">
    </a>
    <a href="https://react.dev">
        <img src="https://img.shields.io/badge/Framework-React-61DAFB?logo=react&logoColor=black" alt="React">
    </a>
    <a href="https://www.typescriptlang.org/">
        <img src="https://img.shields.io/badge/Language-TypeScript-3178C6?logo=typescript&logoColor=white" alt="TypeScript">
    </a>
    <a href="https://tailwindcss.com/">
        <img src="https://img.shields.io/badge/Styling-Tailwind_CSS-38B2AC?logo=tailwind-css&logoColor=white" alt="Tailwind CSS">
    </a>
    <a href="./LICENSE">
        <img src="https://img.shields.io/badge/License-MIT-green.svg" alt="License">
    </a>
    <img src="https://img.shields.io/badge/Status-In_Development-orange" alt="Status">
</div>
</div>

---

## ğŸ“œ Overview

The **Dual Quantum Circuit Simulator** is a sophisticated web application designed to model and visualize a theoretical physics scenario: the behavior of quantum information as it passes through a simulated wormhole. This project explores the fascinating intersection of quantum computing, general relativity, and quantum gravity.

The simulation demonstrates the process of **quantum fragmentation**, where qubit states are deconstructed upon entering the wormhole, and their subsequent **reconstruction** at the exit, all while being influenced by spacetime curvature and exotic matter fields.

ğŸ”— **View your app in AI Studio:** [https://ai.studio/apps/drive/16SRFvYMPoTie2vHFmJyjBSdmwVPs1LWM](https://ai.studio/apps/drive/16SRFvYMPoTie2vHFmJyjBSdmwVPs1LWM)

## âœ¨ Core Features

* **Wormhole Geometry Simulation**: Models the throat geometry and spacetime curvature of a traversable wormhole using configurable physical constants.
* **Quantum State Fragmentation**: Simulates the deconstruction of quantum circuits into fragmented states (`FragmentedState`), each carrying partial information.
* **Majorana Field Interaction**: Incorporates a simulated Majorana fermion field (`MajoranaFieldPoint`) within the wormhole, influencing the phase and amplitude of quantum states.
* **Spacetime Dynamics**: Calculates key relativistic metrics like the Einstein Tensor, Ricci Scalar, and Stress-Energy Tensor (`SpacetimePoint`).
* **Circuit Reconstruction**: Models the reassembly of the original quantum circuits (`ReconstructedCircuit`) from the fragmented states, providing metrics on fidelity and efficiency.
* **Configurable Physics**: Allows for easy modification of fundamental physical constants and wormhole parameters in the `constants.ts` file to test different theoretical scenarios.

## ğŸ› ï¸ Tech Stack

* **Frontend Framework**: [React](https://react.dev/)
* **Language**: [TypeScript](https://www.typescriptlang.org/)
* **Styling**: [Tailwind CSS](https://tailwindcss.com/)
* **Development Server**: [Vite](https://vitejs.dev/)
* **AI Integration (Optional)**: [Google Gemini API](https://ai.google.dev/)

## ğŸš€ Getting Started

Follow these instructions to get a local copy up and running for development and testing purposes.

### Prerequisites

* [Node.js](https://nodejs.org/) (version 18.x or higher is recommended)
* [npm](https://www.npmjs.com/) (usually comes with Node.js)
* A code editor like [Visual Studio Code](https://code.visualstudio.com/)

### Installation

1.  **Clone the Repository**
    ```sh
    git clone [https://github.com/YOUR_USERNAME/YOUR_REPOSITORY.git](https://github.com/YOUR_USERNAME/YOUR_REPOSITORY.git)
    cd YOUR_REPOSITORY
    ```

2.  **Install Dependencies**
    ```sh
    npm install
    ```

3.  **Set Up Environment Variables**
    Create a file named `.env.local` in the root of your project. Add your Google Gemini API key if you plan to use AI features.
    ```env
    # .env.local
    GEMINI_API_KEY="YOUR_GEMINI_API_KEY_HERE"
    ```

4.  **Run the Development Server**
    ```sh
    npm run dev
    ```
    This command starts the Vite development server. Open your browser and navigate to `http://localhost:5173` (or the URL shown in your terminal) to see the application.

## ğŸ”¬ Simulation Concepts & Technical Details

This simulator is built upon a set of custom data structures and theoretical concepts defined in `types.ts`:

* **`QuantumWormholeType`**: This interface defines the core structure of the wormhole. It includes its geometry, spacetime curvature, and the embedded Majorana field. The simulation calculates tunneling probabilities based on the energy state of incoming particles.

* **`FragmentedState`**: When a qubit enters the wormhole, it's modeled as breaking into multiple `FragmentedState` objects. Each fragment contains a portion of the quantum information (alpha, beta amplitudes) and is affected by geometric phase and tunneling probability.

* **`SimulationStep`**: The simulation progresses through a defined lifecycle:
    1.  `creating_wormhole`: Initializing the spacetime geometry.
    2.  `quantum_fragmentation`: Deconstructing the source quantum circuit.
    3.  `wormhole_reconstruction`: Reassembling the destination circuit from fragments.
    4.  `completed`: Final state with all metrics calculated.

* **Physical Constants**: The `constants.ts` file is crucial for the simulation's integrity. It contains simulated values for constants like Planck's constant ($â„$), the gravitational constant ($G$), and parameters for dark energy and Majorana mass, allowing for in-depth theoretical exploration.

The entire process simulates how quantum information might be preserved (or altered) when passing through such an exotic structure, providing metrics like `wormhole_efficiency` and `wormhole_fidelity`.

## ğŸ¤ Contributing

Contributions are what make the open-source community such an amazing place to learn, inspire, and create. Any contributions you make are **greatly appreciated**.

If you have a suggestion that would make this better, please fork the repo and create a pull request. You can also simply open an issue with the tag "enhancement".

1.  Fork the Project
2.  Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3.  Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4.  Push to the Branch (`git push origin feature/AmazingFeature`)
5.  Open a Pull Request

## ğŸ“„ License

Distributed under the MIT License. See `LICENSE` for more information.

---
# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/drive/16SRFvYMPoTie2vHFmJyjBSdmwVPs1LWM

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`
   <div align="center">
  <img width="1200" alt="Banner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
  <br/>
